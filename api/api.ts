/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * This is an **example** API to demonstrate features of the OpenAPI specification. # Introduction This API definition is intended to to be a good starting point for describing your API in [OpenAPI/Swagger format](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md). It also demonstrates features of the [create-openapi-repo](https://github.com/Redocly/create-openapi-repo) tool and the [Redoc](https://github.com/Redocly/Redoc) documentation engine. Beyond the standard OpenAPI syntax, we use a few  [vendor extensions](https://github.com/Redocly/Redoc/blob/main/docs/redoc-vendor-extensions.md). # OpenAPI Specification The goal of The OpenAPI Specification is to define a standard, language-agnostic interface to REST APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined via OpenAPI, a consumer can  understand and interact with the remote service with a minimal amount of implementation logic. Similar to what interfaces have done for lower-level programming, OpenAPI removes the guesswork in calling the service. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Unique identifier for the account
     * @type {string}
     * @memberof Account
     */
    'accountId'?: string;
    /**
     * Full name of the user
     * @type {string}
     * @memberof Account
     */
    'fullName'?: string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof Account
     */
    'email'?: string;
    /**
     * User\'s date of birth
     * @type {string}
     * @memberof Account
     */
    'dateOfBirth'?: string;
    /**
     * User\'s phone number in E.164 format
     * @type {string}
     * @memberof Account
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface AccountV2
 */
export interface AccountV2 {
    /**
     * Unique identifier for the account
     * @type {string}
     * @memberof AccountV2
     */
    'accountId'?: string;
    /**
     * Full name of the user
     * @type {string}
     * @memberof AccountV2
     */
    'fullName'?: string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof AccountV2
     */
    'email'?: string;
    /**
     * User\'s date of birth
     * @type {string}
     * @memberof AccountV2
     */
    'dateOfBirth'?: string;
    /**
     * User\'s phone number in E.164 format
     * @type {string}
     * @memberof AccountV2
     */
    'phoneNumber'?: string;
    /**
     * User\'s race
     * @type {string}
     * @memberof AccountV2
     */
    'race'?: string;
}
/**
 * 
 * @export
 * @interface CreateAccount201Response
 */
export interface CreateAccount201Response {
    /**
     * Unique identifier for the created account
     * @type {string}
     * @memberof CreateAccount201Response
     */
    'accountId'?: string;
    /**
     * Success message
     * @type {string}
     * @memberof CreateAccount201Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * Full name of the user (first and last name combined)
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'fullName': string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'email': string;
    /**
     * User\'s account password
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'password': string;
    /**
     * User\'s phone number in E.164 format
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'phoneNumber'?: string;
    /**
     * User\'s date of birth
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'dateOfBirth'?: string;
}
/**
 * 
 * @export
 * @interface CreateDepartment201Response
 */
export interface CreateDepartment201Response {
    /**
     * Unique identifier for the created department
     * @type {string}
     * @memberof CreateDepartment201Response
     */
    'departmentId'?: string;
    /**
     * Success message
     * @type {string}
     * @memberof CreateDepartment201Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CreateDepartment400Response
 */
export interface CreateDepartment400Response {
    /**
     * Error code indicating the issue
     * @type {string}
     * @memberof CreateDepartment400Response
     */
    'errorCode'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof CreateDepartment400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CreateDepartmentRequest
 */
export interface CreateDepartmentRequest {
    /**
     * Name of the department
     * @type {string}
     * @memberof CreateDepartmentRequest
     */
    'name': string;
    /**
     * Unique code for the department
     * @type {string}
     * @memberof CreateDepartmentRequest
     */
    'code': string;
    /**
     * Additional description of the department
     * @type {string}
     * @memberof CreateDepartmentRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface GetDepartment404Response
 */
export interface GetDepartment404Response {
    /**
     * Error code indicating the issue
     * @type {string}
     * @memberof GetDepartment404Response
     */
    'errorCode'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof GetDepartment404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ListAccounts1500Response
 */
export interface ListAccounts1500Response {
    /**
     * Error code indicating the issue
     * @type {string}
     * @memberof ListAccounts1500Response
     */
    'code': string;
    /**
     * Detailed error message
     * @type {string}
     * @memberof ListAccounts1500Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ListDepartments200ResponseInner
 */
export interface ListDepartments200ResponseInner {
    /**
     * Unique identifier for the department
     * @type {string}
     * @memberof ListDepartments200ResponseInner
     */
    'departmentId'?: string;
    /**
     * Name of the department
     * @type {string}
     * @memberof ListDepartments200ResponseInner
     */
    'name'?: string;
    /**
     * Code of the department
     * @type {string}
     * @memberof ListDepartments200ResponseInner
     */
    'code'?: string;
    /**
     * Additional description of the department
     * @type {string}
     * @memberof ListDepartments200ResponseInner
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface LoginUser200Response
 */
export interface LoginUser200Response {
    /**
     * JWT access token
     * @type {string}
     * @memberof LoginUser200Response
     */
    'accessToken'?: string;
    /**
     * Refresh token for generating new access tokens
     * @type {string}
     * @memberof LoginUser200Response
     */
    'refreshToken'?: string;
    /**
     * Access token expiration time in seconds
     * @type {number}
     * @memberof LoginUser200Response
     */
    'expiresIn'?: number;
    /**
     * Type of token returned
     * @type {string}
     * @memberof LoginUser200Response
     */
    'tokenType'?: string;
}
/**
 * 
 * @export
 * @interface LoginUser400Response
 */
export interface LoginUser400Response {
    /**
     * Error code indicating the issue
     * @type {string}
     * @memberof LoginUser400Response
     */
    'errorCode'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof LoginUser400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface LoginUser401Response
 */
export interface LoginUser401Response {
    /**
     * Error code indicating the issue
     * @type {string}
     * @memberof LoginUser401Response
     */
    'errorCode'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof LoginUser401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface LoginUser500Response
 */
export interface LoginUser500Response {
    /**
     * Error code indicating the issue
     * @type {string}
     * @memberof LoginUser500Response
     */
    'errorCode'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof LoginUser500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface LoginUserRequest
 */
export interface LoginUserRequest {
    /**
     * User\'s email address
     * @type {string}
     * @memberof LoginUserRequest
     */
    'email': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof LoginUserRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error code indicating the issue
     * @type {string}
     * @memberof ModelError
     */
    'code': string;
    /**
     * Detailed error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * Total number of items available
     * @type {number}
     * @memberof Pagination
     */
    'totalItems'?: number;
    /**
     * Total number of pages available
     * @type {number}
     * @memberof Pagination
     */
    'totalPages'?: number;
    /**
     * The current page number
     * @type {number}
     * @memberof Pagination
     */
    'currentPage'?: number;
    /**
     * Number of items per page
     * @type {number}
     * @memberof Pagination
     */
    'itemsPerPage'?: number;
    /**
     * List of items for the current page
     * @type {Array<Account>}
     * @memberof Pagination
     */
    'items'?: Array<Account>;
}
/**
 * 
 * @export
 * @interface PaginationV2
 */
export interface PaginationV2 {
    /**
     * Total number of items available
     * @type {number}
     * @memberof PaginationV2
     */
    'totalItems'?: number;
    /**
     * Total number of pages available
     * @type {number}
     * @memberof PaginationV2
     */
    'totalPages'?: number;
    /**
     * The current page number
     * @type {number}
     * @memberof PaginationV2
     */
    'currentPage'?: number;
    /**
     * Number of items per page
     * @type {number}
     * @memberof PaginationV2
     */
    'itemsPerPage'?: number;
    /**
     * List of items for the current page
     * @type {Array<AccountV2>}
     * @memberof PaginationV2
     */
    'items'?: Array<AccountV2>;
}
/**
 * 
 * @export
 * @interface UpdateAccount200Response
 */
export interface UpdateAccount200Response {
    /**
     * Unique identifier for the updated account
     * @type {string}
     * @memberof UpdateAccount200Response
     */
    'accountId'?: string;
    /**
     * Success message
     * @type {string}
     * @memberof UpdateAccount200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
    /**
     * Full name of the user (first and last name combined)
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'fullName'?: string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'email'?: string;
    /**
     * User\'s phone number in E.164 format
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'phoneNumber'?: string;
    /**
     * User\'s date of birth
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'dateOfBirth'?: string;
}
/**
 * 
 * @export
 * @interface UpdateDepartment200Response
 */
export interface UpdateDepartment200Response {
    /**
     * Unique identifier for the updated department
     * @type {string}
     * @memberof UpdateDepartment200Response
     */
    'departmentId'?: string;
    /**
     * Success message
     * @type {string}
     * @memberof UpdateDepartment200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UpdateDepartmentRequest
 */
export interface UpdateDepartmentRequest {
    /**
     * Name of the department
     * @type {string}
     * @memberof UpdateDepartmentRequest
     */
    'name'?: string;
    /**
     * Unique code for the department
     * @type {string}
     * @memberof UpdateDepartmentRequest
     */
    'code'?: string;
    /**
     * Additional description of the department
     * @type {string}
     * @memberof UpdateDepartmentRequest
     */
    'description'?: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user account with basic details.
         * @summary Create a new account
         * @param {CreateAccountRequest} createAccountRequest Account creation details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing user account by its ID.
         * @summary Delete an account
         * @param {string} accountId Unique identifier for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/v1/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details of a single user account by its ID.
         * @summary Retrieve a single account
         * @param {string} accountId Unique identifier for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            const localVarPath = `/v1/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all user accounts with pagination support.
         * @summary List all accounts
         * @param {number} [limit] Number of accounts to retrieve
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listAccounts: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all user accounts with pagination support.
         * @summary List all accounts
         * @param {number} [limit] Number of accounts to retrieve
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts1: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates details of an existing user account.
         * @summary Update an account
         * @param {string} accountId Unique identifier for the account
         * @param {UpdateAccountRequest} updateAccountRequest Updated account details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (accountId: string, updateAccountRequest: UpdateAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            // verify required parameter 'updateAccountRequest' is not null or undefined
            assertParamExists('updateAccount', 'updateAccountRequest', updateAccountRequest)
            const localVarPath = `/v1/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new user account with basic details.
         * @summary Create a new account
         * @param {CreateAccountRequest} createAccountRequest Account creation details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccount201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an existing user account by its ID.
         * @summary Delete an account
         * @param {string} accountId Unique identifier for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.deleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves details of a single user account by its ID.
         * @summary Retrieve a single account
         * @param {string} accountId Unique identifier for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all user accounts with pagination support.
         * @summary List all accounts
         * @param {number} [limit] Number of accounts to retrieve
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async listAccounts(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.listAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all user accounts with pagination support.
         * @summary List all accounts
         * @param {number} [limit] Number of accounts to retrieve
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts1(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts1(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.listAccounts1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates details of an existing user account.
         * @summary Update an account
         * @param {string} accountId Unique identifier for the account
         * @param {UpdateAccountRequest} updateAccountRequest Updated account details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountId, updateAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.updateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Creates a new user account with basic details.
         * @summary Create a new account
         * @param {CreateAccountRequest} createAccountRequest Account creation details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(createAccountRequest: CreateAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAccount201Response> {
            return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing user account by its ID.
         * @summary Delete an account
         * @param {string} accountId Unique identifier for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details of a single user account by its ID.
         * @summary Retrieve a single account
         * @param {string} accountId Unique identifier for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.getAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all user accounts with pagination support.
         * @summary List all accounts
         * @param {number} [limit] Number of accounts to retrieve
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listAccounts(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Pagination> {
            return localVarFp.listAccounts(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all user accounts with pagination support.
         * @summary List all accounts
         * @param {number} [limit] Number of accounts to retrieve
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts1(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginationV2> {
            return localVarFp.listAccounts1(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates details of an existing user account.
         * @summary Update an account
         * @param {string} accountId Unique identifier for the account
         * @param {UpdateAccountRequest} updateAccountRequest Updated account details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateAccount200Response> {
            return localVarFp.updateAccount(accountId, updateAccountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Creates a new user account with basic details.
     * @summary Create a new account
     * @param {CreateAccountRequest} createAccountRequest Account creation details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(createAccountRequest: CreateAccountRequest, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing user account by its ID.
     * @summary Delete an account
     * @param {string} accountId Unique identifier for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves details of a single user account by its ID.
     * @summary Retrieve a single account
     * @param {string} accountId Unique identifier for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all user accounts with pagination support.
     * @summary List all accounts
     * @param {number} [limit] Number of accounts to retrieve
     * @param {number} [offset] Offset for pagination
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccounts(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all user accounts with pagination support.
     * @summary List all accounts
     * @param {number} [limit] Number of accounts to retrieve
     * @param {number} [offset] Offset for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts1(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccounts1(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates details of an existing user account.
     * @summary Update an account
     * @param {string} accountId Unique identifier for the account
     * @param {UpdateAccountRequest} updateAccountRequest Updated account details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(accountId, updateAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticates a user and returns an access token.
         * @summary User login
         * @param {LoginUserRequest} loginUserRequest User login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginUserRequest: LoginUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginUserRequest' is not null or undefined
            assertParamExists('loginUser', 'loginUserRequest', loginUserRequest)
            const localVarPath = `/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticates a user and returns an access token.
         * @summary User login
         * @param {LoginUserRequest} loginUserRequest User login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginUserRequest: LoginUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Authenticates a user and returns an access token.
         * @summary User login
         * @param {LoginUserRequest} loginUserRequest User login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginUserRequest: LoginUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginUser200Response> {
            return localVarFp.loginUser(loginUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Authenticates a user and returns an access token.
     * @summary User login
     * @param {LoginUserRequest} loginUserRequest User login credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public loginUser(loginUserRequest: LoginUserRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginUser(loginUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DepartmentsApi - axios parameter creator
 * @export
 */
export const DepartmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new department with basic details.
         * @summary Create a new department
         * @param {CreateDepartmentRequest} createDepartmentRequest Department creation details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepartment: async (createDepartmentRequest: CreateDepartmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDepartmentRequest' is not null or undefined
            assertParamExists('createDepartment', 'createDepartmentRequest', createDepartmentRequest)
            const localVarPath = `/v1/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDepartmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing department by its ID.
         * @summary Delete a department
         * @param {string} departmentId Unique identifier for the department
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDepartment: async (departmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'departmentId' is not null or undefined
            assertParamExists('deleteDepartment', 'departmentId', departmentId)
            const localVarPath = `/v1/departments/{departmentId}`
                .replace(`{${"departmentId"}}`, encodeURIComponent(String(departmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details of a single department by its ID.
         * @summary Retrieve a single department
         * @param {string} departmentId Unique identifier for the department
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartment: async (departmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'departmentId' is not null or undefined
            assertParamExists('getDepartment', 'departmentId', departmentId)
            const localVarPath = `/v1/departments/{departmentId}`
                .replace(`{${"departmentId"}}`, encodeURIComponent(String(departmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all departments.
         * @summary List all departments
         * @param {number} [limit] Number of departments to retrieve
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDepartments: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates details of an existing department.
         * @summary Update a department
         * @param {string} departmentId Unique identifier for the department
         * @param {UpdateDepartmentRequest} updateDepartmentRequest Updated department details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDepartment: async (departmentId: string, updateDepartmentRequest: UpdateDepartmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'departmentId' is not null or undefined
            assertParamExists('updateDepartment', 'departmentId', departmentId)
            // verify required parameter 'updateDepartmentRequest' is not null or undefined
            assertParamExists('updateDepartment', 'updateDepartmentRequest', updateDepartmentRequest)
            const localVarPath = `/v1/departments/{departmentId}`
                .replace(`{${"departmentId"}}`, encodeURIComponent(String(departmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDepartmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepartmentsApi - functional programming interface
 * @export
 */
export const DepartmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepartmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new department with basic details.
         * @summary Create a new department
         * @param {CreateDepartmentRequest} createDepartmentRequest Department creation details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepartment(createDepartmentRequest: CreateDepartmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDepartment201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDepartment(createDepartmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.createDepartment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an existing department by its ID.
         * @summary Delete a department
         * @param {string} departmentId Unique identifier for the department
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDepartment(departmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDepartment(departmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.deleteDepartment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves details of a single department by its ID.
         * @summary Retrieve a single department
         * @param {string} departmentId Unique identifier for the department
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepartment(departmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDepartments200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepartment(departmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.getDepartment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all departments.
         * @summary List all departments
         * @param {number} [limit] Number of departments to retrieve
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDepartments(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListDepartments200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDepartments(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.listDepartments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates details of an existing department.
         * @summary Update a department
         * @param {string} departmentId Unique identifier for the department
         * @param {UpdateDepartmentRequest} updateDepartmentRequest Updated department details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDepartment(departmentId: string, updateDepartmentRequest: UpdateDepartmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDepartment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDepartment(departmentId, updateDepartmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.updateDepartment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DepartmentsApi - factory interface
 * @export
 */
export const DepartmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepartmentsApiFp(configuration)
    return {
        /**
         * Creates a new department with basic details.
         * @summary Create a new department
         * @param {CreateDepartmentRequest} createDepartmentRequest Department creation details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepartment(createDepartmentRequest: CreateDepartmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateDepartment201Response> {
            return localVarFp.createDepartment(createDepartmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing department by its ID.
         * @summary Delete a department
         * @param {string} departmentId Unique identifier for the department
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDepartment(departmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDepartment(departmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details of a single department by its ID.
         * @summary Retrieve a single department
         * @param {string} departmentId Unique identifier for the department
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartment(departmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListDepartments200ResponseInner> {
            return localVarFp.getDepartment(departmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all departments.
         * @summary List all departments
         * @param {number} [limit] Number of departments to retrieve
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDepartments(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListDepartments200ResponseInner>> {
            return localVarFp.listDepartments(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates details of an existing department.
         * @summary Update a department
         * @param {string} departmentId Unique identifier for the department
         * @param {UpdateDepartmentRequest} updateDepartmentRequest Updated department details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDepartment(departmentId: string, updateDepartmentRequest: UpdateDepartmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateDepartment200Response> {
            return localVarFp.updateDepartment(departmentId, updateDepartmentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepartmentsApi - object-oriented interface
 * @export
 * @class DepartmentsApi
 * @extends {BaseAPI}
 */
export class DepartmentsApi extends BaseAPI {
    /**
     * Creates a new department with basic details.
     * @summary Create a new department
     * @param {CreateDepartmentRequest} createDepartmentRequest Department creation details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public createDepartment(createDepartmentRequest: CreateDepartmentRequest, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).createDepartment(createDepartmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing department by its ID.
     * @summary Delete a department
     * @param {string} departmentId Unique identifier for the department
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public deleteDepartment(departmentId: string, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).deleteDepartment(departmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves details of a single department by its ID.
     * @summary Retrieve a single department
     * @param {string} departmentId Unique identifier for the department
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public getDepartment(departmentId: string, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).getDepartment(departmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all departments.
     * @summary List all departments
     * @param {number} [limit] Number of departments to retrieve
     * @param {number} [offset] Offset for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public listDepartments(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).listDepartments(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates details of an existing department.
     * @summary Update a department
     * @param {string} departmentId Unique identifier for the department
     * @param {UpdateDepartmentRequest} updateDepartmentRequest Updated department details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public updateDepartment(departmentId: string, updateDepartmentRequest: UpdateDepartmentRequest, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).updateDepartment(departmentId, updateDepartmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



